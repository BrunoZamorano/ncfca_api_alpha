status: pending

# 03 — Refatorar Serviços e Módulos para Utilizar o `ConfigService`

## Objetivo
Atualizar todos os pontos da aplicação que ainda acessam `process.env` diretamente, refatorando-os para utilizar o `ConfigService`. Isso centraliza o acesso à configuração e garante que toda a aplicação respeite o ambiente carregado pelo `ConfigModule`.

## Arquivos e Caminhos
- `src/infraestructure/services/token-service-jwt.ts` (modificar)
- `src/shared/guards/webhook/webhook.guard.ts` (modificar)
- `src/shared/modules/club-request.module.ts` (modificar)
- `src/admin.seed.ts` (modificar)
- `src/infraestructure/services/hashing-bcrypct.service.ts` (modificar)

## Passo a Passo

### 1. `token-service-jwt.ts`
- **Ação:** Injetar `ConfigService` e usar para carregar as variáveis de token.
- No construtor, adicione `private readonly configService: ConfigService`.
- Substitua as inicializações de propriedades:
  - `process.env.REFRESH_TOKEN_SECRET` -> `this.configService.get<string>('REFRESH_TOKEN_SECRET')`
  - `process.env.ACCESS_TOKEN_SECRET` -> `this.configService.get<string>('ACCESS_TOKEN_SECRET')`
  - `process.env.ACCESS_TOKEN_EXPIRATION` -> `this.configService.get<string>('ACCESS_TOKEN_EXPIRATION')`
  - `process.env.REFRESH_TOKEN_EXPIRATION` -> `this.configService.get<string>('REFRESH_TOKEN_EXPIRATION')`

### 2. `webhook.guard.ts`
- **Ação:** Injetar `ConfigService` para obter o segredo do webhook.
- No construtor, adicione `private readonly configService: ConfigService`.
- Dentro do método `canActivate`, substitua a leitura da variável:
  - `process.env.PAYMENT_WEBHOOK_SECRET` -> `this.configService.get<string>('PAYMENT_WEBHOOK_SECRET')`

### 3. `club-request.module.ts`
- **Ação:** Usar `ConfigModule` e `ConfigService` para configurar a conexão com o RabbitMQ de forma assíncrona.
- Altere o registro do `ClientProxy` para usar `useFactory`.
- A factory injetará o `ConfigService` e o usará para obter a `RABBITMQ_URL`.

  **Exemplo de implementação:**
  ```typescript
  // ... imports
  import { ConfigModule, ConfigService } from '@nestjs/config';

  // ...
  imports: [ConfigModule],
  providers: [
    {
      provide: CLUB_EVENTS_SERVICE,
      useFactory: (configService: ConfigService) => ({
        transport: Transport.RMQ,
        options: {
          urls: [configService.get<string>('RABBITMQ_URL') || ''],
          // ... resto das opções
        },
      }),
      inject: [ConfigService],
    },
  ],
  ```

### 4. `admin.seed.ts`
- **Ação:** Passar o `ConfigService` para a função de seed.
- A função `adminSeed` precisa receber a instância do `ConfigService`.
- Em `main.ts`, ao chamar `adminSeed(app)`, passe também o `configService`: `adminSeed(app, configService)`.
- Na função `adminSeed`, receba o `configService` como argumento e use-o para obter `ADMIN_EMAIL` e `ADMIN_PASSWORD`.

### 5. `hashing-bcrypct.service.ts`
- **Ação:** Injetar `ConfigService` para obter o número de salt rounds.
- No construtor, adicione `private readonly configService: ConfigService`.
- Substitua a inicialização da propriedade:
  - `Number(process.env.BCRYPT_SALT_ROUNDS)` -> `this.configService.get<number>('BCRYPT_SALT_ROUNDS')`

## Critérios de Aceite
- Todos os arquivos listados foram refatorados para usar `ConfigService` em vez de `process.env`.
- A injeção de dependência do `ConfigService` foi feita corretamente nos construtores das classes de serviço/guards.
- A configuração assíncrona no `club-request.module.ts` foi implementada usando `useFactory`.
- A aplicação continua a funcionar normalmente após as refatorações (login, etc.).

## Testes Mínimos
- Execute `pnpm test:e2e` e verifique se os testes passam.
