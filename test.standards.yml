test_standards:
  - code-standards: @code.standards.yml
  - utilize jest
  - id: arrange_act_assert
    rule: "Follow the Arrange–Act–Assert steps."
    bad_example: |
      it("creates a club", async () => {
        const result = await createClub({ name: "Chess" });
        expect(result.id).toBeDefined();
        const found = await repo.findByName("Chess");
        expect(found).not.toBeNull(); // Mixed flow, no clear phases
      });
    good_example: |
      it("creates a club", async () => {
        // Arrange
        const input = { name: "Chess" };

        // Act
        const result = await createClub(input);

        // Assert
        expect(result.id).toBeDefined();
        await expect(repo.findByName("Chess")).resolves.toMatchObject(input);
      })

  - id: independent_tests
    rule: "Tests should be independent from one another."
    bad_example: |
      let createdId: string;

      it("A) creates a club", async () => {
        createdId = (await createClub({ name: "Music" })).id; // shared mutable state
      });

      it("B) finds the previously created club", async () => {
        const c = await repo.findById(createdId); // depends on test A
        expect(c?.name).toBe("Music");
      });
    good_example: |
      it("creates a club", async () => {
        const { id } = await createClub({ name: "Music" });
        const found = await repo.findById(id);
        expect(found?.name).toBe("Music");
      });

      it("finds a club by name", async () => {
        await createClub({ name: "Art" });
        const found = await repo.findByName("Art");
        expect(found?.name).toBe("Art");
      });

  - id: one_behavior_per_test
    rule: "Test only one behavior per test case."
    bad_example: |
      it("creates and deletes a club", async () => {
        const c = await createClub({ name: "Drama" });
        expect(c.id).toBeDefined();
        await deleteClub(c.id);
        await expect(repo.findById(c.id)).resolves.toBeNull();
      });
    good_example: |
      it("creates a club", async () => {
        const c = await createClub({ name: "Drama" });
        expect(c.id).toBeDefined();
      });

      it("deletes a club", async () => {
        const c = await createClub({ name: "Drama" });
        await deleteClub(c.id);
        await expect(repo.findById(c.id)).resolves.toBeNull();
      });

  - id: prepare_environment_beforeEach
    rule: "Prepare the environment in beforeEach."
    example: |
      beforeEach(async () => {
        await db.reset();       // clear tables
        jest.clearAllMocks();   // reset spies/mocks
      });

      it("persists a club", async () => {
        const c = await createClub({ name: "Board Games" });
        expect(await repo.findById(c.id)).toBeTruthy();
      });

  - id: close_connections_afterAll_or_afterEach
    rule: "Always close open connections in afterAll/afterEach."
    example: |
      import { server } from "@/infra/http/server";
      import { db } from "@/infra/db";

      afterEach(async () => {
        await db.releaseTransactionIfAny(); // per-test cleanup if needed
      });

      afterAll(async () => {
        await db.disconnect();  // close DB pool
        await new Promise<void>((resolve) => server.close(() => resolve()));
      });
      
      - o formato da descrição do teste deve ser assim
      - ter um describe com o nome do teste "(UNIT | INT | E2E ) ApproveCandidate" nome do teste (geralmente nome do use case)
      - os testes e2e não devem ter (POST) parara não não, nada desses dertalhes que não servem de nada. um teste garante uma regra de negócio, ponto. então os nomes dos it('[business-rule]') deve ser 1 em português, obedecendo a linguagem ubíqua do projeto e sepre assim 'Deve poder,fazer,deixar,aprovar,etc...' ou 'Não Deve ...' sempre que possível. 